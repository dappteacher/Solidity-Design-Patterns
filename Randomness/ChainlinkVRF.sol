/*
### Using Chainlink VRF

**Install Chainlink Contracts**: First, you need to install the Chainlink contracts. 
If you are using Hardhat or Truffle, you can add the Chainlink contracts library.

```bash
npm install @chainlink/contracts
*/

// SPDX-License-Identifier: MIT
// Author: Yaghoub Adelzadeh
// GitHub: https://www.github.com/dappteacher
pragma solidity ^0.8.25;

import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";

/// @title Chainlink VRF Randomness Contract
/// @dev This contract generates secure randomness using Chainlink VRF.
contract ChainlinkVRF is VRFConsumerBase {

    // Chainlink VRF variables
    bytes32 internal keyHash;
    uint256 internal fee;
    mapping(bytes32 => uint256) public randomResults;

    /// @dev Event emitted when a random number is requested
    /// @param requestId The ID of the randomness request
    event RandomnessRequested(bytes32 indexed requestId);

    /// @dev Event emitted when a random number is fulfilled
    /// @param requestId The ID of the randomness request
    /// @param randomNumber The generated random number
    event RandomnessFulfilled(bytes32 indexed requestId, uint256 randomNumber);

    /// @dev Constructor to initialize the Chainlink VRF variables
    /// @param vrfCoordinator Address of the VRF Coordinator
    /// @param linkToken Address of the LINK token
    /// @param vrfKeyHash Key hash of the VRF
    /// @param vrfFee Fee for the VRF request
    constructor(
        address vrfCoordinator,
        address linkToken,
        bytes32 vrfKeyHash,
        uint256 vrfFee
    )
        VRFConsumerBase(vrfCoordinator, linkToken)
    {
        keyHash = vrfKeyHash;
        fee = vrfFee;
    }

    /// @notice Requests randomness from Chainlink VRF
    /// @dev Requires LINK token balance to pay for the request
    /// @return requestId The ID of the randomness request
    function requestRandomness() public returns (bytes32 requestId) {
        require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK - fill contract with faucet");
        requestId = requestRandomness(keyHash, fee);
        emit RandomnessRequested(requestId);
        return requestId;
    }

    /// @dev Callback function used by VRF Coordinator
    /// @param requestId ID of the request
    /// @param randomness Random number generated by Chainlink VRF
    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
        randomResults[requestId] = randomness;
        emit RandomnessFulfilled(requestId, randomness);
    }

    /// @notice Withdraw LINK tokens from the contract
    /// @dev Only the contract owner can withdraw LINK tokens
    function withdrawLink() external {
        require(LINK.transfer(msg.sender, LINK.balanceOf(address(this))), "Unable to transfer");
    }
}


/*
### Explanation:

- **SPDX License Identifier**: Specifies the license type for the contract.
- **pragma solidity ^0.8.0**: Specifies the Solidity compiler version to be used.
- **VRFConsumerBase**: Inherits from the Chainlink VRF consumer base contract.
- **Chainlink VRF Variables**: `keyHash`, `fee`, and `randomResult` are used for the VRF process.
- **Constructor**: Initializes the Chainlink VRF variables.
- **requestRandomness Function**: Requests randomness from Chainlink VRF. It requires enough LINK tokens in the contract.
- **fulfillRandomness Function**: Callback function that receives the random number from the Chainlink VRF Coordinator.
- **withdrawLink Function**: Allows withdrawing LINK tokens from the contract (typically by the owner).

### Notes:

1. **Funding the Contract**: Ensure the contract has enough LINK tokens to pay for the VRF request fee. 
    You can get LINK tokens from the Chainlink Faucet for testnets.
2. **Deployment Parameters**: When deploying the contract, use the appropriate addresses 
    for `vrfCoordinator`, `linkToken`, and `vrfKeyHash` based on the network you are deploying to 
    (e.g., Ethereum mainnet, Rinkeby testnet, etc.).
3. **Security**: Using Chainlink VRF is a secure and reliable way to generate randomness, as the random number generation 
    process is decentralized and verifiable.

By using Chainlink VRF, you ensure that the randomness is not only secure but also verifiable by anyone, 
making it suitable for applications requiring high security and transparency.
*/
